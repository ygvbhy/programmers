# 자료구조 (Data Structure)

- 자료구조는 다수의 자료(data)를 담기 위한 구조.
- 데이터의 수가 많아질수록 효율적인 자료구조가 필요
- 예) 학생 수가 1,000,000명 이상인 학생 관리 프로그램

## 자료구조의 개요

- 자료구조의 필요성에 대해 이해할 필요가 있다.
- 성능 비교: 자료구조/알고리즘의 성능 측정 방법에 대해 이해할 필요가 있다.
  예) 삽입 : O(logN) / 추출 : O(logN) vs 삽입 : O(N) / 추출 : O(1)

## 자료구조의 필요성

- 데이터를 효과적으로 저장하고, 처리하는 방법에 대해 바르게 이해할 필요가 있다.
- 자료구조를 제대로 이해하지 못하면 불필요하게 메모리와 계산을 낭비할 여지가 있다.

- C 언어를 기준으로 정수 (int) 형식의 데이턱가 100만개 가량이 존재한다고 가정.
- 해당 프로그램을 이용하면, 내부적으로 하루에 데이터 조회가 1억 번 이상 발생
- 이때 원하는 데이터를 가장 빠르게 찾도록 해주는 자료구조는 무엇일까 ?
  -> 트리(Tree) 와 같은 자료구조를 활용할 수 있다.

## 자료구조의 종류

1. 선형 구조 (linear data structure)

- 배열(Array)
- 연결 리스트(Linked List)
- 스택(Stack)
- 큐(Queue)

2. 비선형 구조 (non-linear data structure)

- 트리(Tree)
- 그래프(Graph)

## 선형 자료구조

- 선형 자료구조는 하나의 데이터 뒤에 다른 데이터가 하나 존재하는 자료구조
- 데이터가 일렬로 연속적으로(순차적으로) 연결되어 있다.
  ex) 배열, 연결 리스트, 스택, 큐

## 비선형 자료구조

- 비선형 자료구조는 하나의 데이터 뒤에 다른 데이터가 여러 개 올 수 있는 자료구조다.
- 데이터가 일직선상으로 연결되어 있지 않아도 된다.
  ex) 트리, 그래프

## 자료구조와 알고리즘

1. 효율적인 자룍구조 섥계를 위해 알고리즘 지식이 필요
2. 효율적인 알고리즘을 작성하기 위해서 문제 상황에 맞는 적절한 자료구조가 사용되어야 한다.
3. 프로그램을 작성할 때 자료구조와 알고리즘 모두 고려해야 한다.

## 프록그램 성능 측정 방법

- 시간 복잡도 (Time Complexity) : 알고리즘에 사용되는 연산 횟수로 측정
- 공간 복잡도 (Space Complexity) : 알고리즘에 사용되는 메모리 양으로 측정
- 공간을 많이 사용하는 대신 시간을 단축하는 방법이 흔히 사용된다.

## Big-O 표기법

- 복잡도를 표현할 때는 Big-O 표기법을 사용한다.

1. 특정한 알고리즘이 얼마나 효율적ㄱ인지 수치적으로 표현할 수 있다.
2. 가장 빠르게 증가하는 항만을 고려하는 표기법

- 일반적으로 연산 횟수가 **10억**을 넘어가면 1초 이상의 시간이 소요된다.
  예) n이 1,000 일때
  O(N): 약 1,000번 연산
  O(NlogN): 약 10,000번 연산
  O(N^2): 약 1,000,000번 연산
  O(N^3): 약 1,000,000,000번 연산

- Big-O 표기법으로 시간 복잡도를 표기할 때는 가장 큰 항만을 표시한다.
- 가장 큰 항에 붙어있는 계수는 제거한다.
  O(3N^2 + N) = O(N^2)
- 현실 세계에서는 동작 시간이 1초 이내인 알고리즘을 설계할 필요가 있다.

매모리의 크기를 나타낼 때는 일반적으로 MB(메가바이트) 단위를 사용한다.
int a[1000] = 4KB
int a[1000000] = 4MB
int a[2000][2000] = 16MB

# 배열 (Array)

- 가장 기본적인 자료구조
- 여러 개의 변수를 담는 공간으로 이해할 수 있다.
- 배열은 인덱스(index)가 존재하며, 인덱스는 0 부터 시작한다.
- 특정한 인덱스에 직접적으로 접근 가능 -> 수행시간 O(1)

| 인덱스 | 0   | 1   | 2   | 3   | 4   |
| ------ | --- | --- | --- | --- | --- |
| 값     | 1   | 2   | 3   | 4   | 5   |

## 배열의 특징

- 컴퓨터의 메인 메모리에서 배열의 공간은 연속적으로 할당된다.
  장점: **캐시(cache)** 히트 가능성이 높으며, 조회가 빠르다.
  단점: 배열의 크기를 미리 지정해야 하는 것이 일반적이므로, 데이터의 추가 및 삭제에 한계가 있다.

| 메모리 주소 | 0x0000 | 0x0004 | 0x0008 |
| ----------- | ------ | ------ | ------ |
| 인덱스      | 0      | 1      | 2      |
| 값          | 25     | 75     | 83     |

## 연결 리스트 (Linked List)

- **연결 리스트**는 컴퓨터의 메인 메모리상에서 주소가 연속적이지 않다.
- 배열과 다르게 크기가 정해져 있지 않고, 리스트의 크기는 동적으로 변경 가능하다.
  장점: **포인터(pointer)**를 통해 다음 데이터의 위치를 가리킨다는 점에서 **삽입과 삭제가 간편** 하다.
  단점: 특정 번째의 원소를 검색할 때는 앞에서부터 원소를 찾아야 하므로, 데이터의 검색 속도가 느리다.

## Javascript 의 배열

- 일반적인 프로그래밍 언어에서의 배열로 이해할 수 있다.
- js 의 배열은 일반 배열처럼 임의의 인덱스를 이용해 직접적인 접근이 가능하다.
- js 의 배열은 동적 배열의 기능을 제공하여, 맨 뒤의 위치에 원소 추가가 가능하다.
- js 의 배열 자료형은 동적 배열이다.
- 배열의 용량이 가득 차면, 자동으로 큭기를 증가시킨다.
- 내부저으로 포인터(pointer)를 사용하여, 연결 리스트의 장점도 가지고 있다.
- 배열 혹은 스택의 기능이 필요할 때 사용할 수 이싿.
  [참고] 큐의 기능을 제공하지 못한다.(비효율적)

### js 배열 초기화 1) 대괄호 사용

```
let arr = [];

arr.push(1);
arr.push(2);
arr.push(3);

for(let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}

// 결과
// 1
// 2
// 3
```

### js 배열 초기화 2) Array() 사용

- js 에서는 Array() 를 이용해 간단히 배열을 생성할 수 있다.

```
let arr = new Array();

arr.push(1);
arr.push(2);
arr.push(3);

for(let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}

// 결과
// 1
// 2
// 3
```

### 배열 초기화

- js 의 배열은 일반적인 변수 외에도 객체를 담을 수도 있다.

```
let arr = ["Hello", 888, true];

console.log(arr);

// 결과
// ["Hello", 888, true]
```

- js 에서는 임의의 크기를 가지는 배열을 만들 수 있다.
- 원하는 값을 직접 입력하여 초기화 할 수 있다.
- 크기가 N 인 1차원 배열을 만드는 방법은 다음과 같다.

```
// 원하는 값을 직접 입력하여 초기화
let arr = [1, 2, 3, 4, 5];
console.log(arr);

// 하나의 값으로 초기화
let arr2 = Array.from({length: 5}, () => 7);
console.log(arr2);

// 결과
// [1, 2, 3, 4, 5]
// [7, 7, 7, 7, 7]
```

### 크기가 N X M 인 2차원 리스트(배열) 만들기 1

- 2차원 배열이 필요할 때는 다음과 같이 원하는 값을 직접 넣어 초기화할 수 있다.

```
// 원하는 값을 직접 입력하여 초기화
let arr1 = [
  [0, 1, 2, 3],
  [4, 5, 6, 7],
  [8, 9, 10, 11]
];

// 결과
// [
//   [0, 1, 2, 3],
//   [4, 5, 6, 7],
//   [8, 9, 10, 11]
//]
```

### 크기가 N X M 인 2차원 리스트(배열) 만들기 2

- 최신 js 환경 (ES6 이상) 에서 사용할 수 있는 문법이다.
- 한 줄로 2차원 배열을 초기화할 수 있다.
- 배열의 각 원소에 킈가 5인 배열을 할당한다.

```
let arrr = Array.from(Array(4), () => new Array(5));
console.log(arr);

// 결과
// [
//   [undefined, undefined, undefined, undefined, undefined],
//   [undefined, undefined, undefined, undefined, undefined],
//   [undefined, undefined, undefined, undefined, undefined],
//   [undefined, undefined, undefined, undefined, undefined]
// ]
```

### 크기가 N X M 인 2차원 리스트(배열) 만들기 3

- 다음과 같이 반복문을 이용해 2차원 배열을 초기화할 수 있다.

```
// 반복문을 이용해 배열 초기화
let arr2 = new Array(3);
for (let i = 0; i < arr2.length; i++){
  arr2[i] = Array.from({length: 4}, (undefined, j) => i * 4 + j);
}

console.log(arr2);

// 결과
// [
//   [0, 1, 2, 3],
//   [4, 5, 6, 7],
//   [8, 9, 10, 11]
// ]
```

## 배열 다루기

- js 의 배열은 동적 배열이다.
- 배열이 생성된 이후에도 배열의 크기를 임의로 변경할 수 있다.
- push() 매서드를 통해 배열의 가장 뒤쪽에 새로운 원소를 추가할 수 있다.

```
let arr = [5,6,7,8,9];
arr.length = 8
arr[7] = 3;
arr.push(1);

for (let x of arr) {
  console.log(x);
}

// 결과
// 5
// 6
// 7
// 8
// 9
// undefined
// undefined
// 3
// 1
```

## 배열의 대표적인 메서드

- concat(): 여러 개의 배열을 이어 붙여서 합친 결과를 반환 한다. O(N)

```
let arr1 = [1, 2, 3, 4, 5];
let arr2 = [6, 7, 8, 9, 10];
let arr = arr1.concat(arr2, [11, 12], [13]);
console.log(arr);

// 결과
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
```

- slice(left, right): 특정 구간의 원소를 꺼낸 배열을 반환한다. O(N)

```
let arr = [1, 2, 3, 4, 5];
let result = arr.slice(2, 4);
console.log(result);

// 결과
// [3, 4]
```

- indexOf(): 특정한 값을 가지는 원소의 첫째 인덱스를 반환한다. O(N)
- 만약 해당하는 원소가 없는 경우 -1 을 반환한다.

```
let arr = [1, 2, 3, 4, 5];
let result = arr.indexOf(3);
console.log(result);

// 결과
// 2
```

## 연결 리스트

- 연결 리스트는 각 노드가 한 줄로 연결되어 있는 자료 구조다.
- 각 노드는 (데이터, 포인터) 형태를 가진다.
- 포인터: 다음 노드의 메모리 주소를 가리키는 목적으로 사용된다.
- 연결성: 각 노드의 포인터는 다음 혹은 이전 노드를 가리킨다.

- 연결 리스트를 이용하면 다양한 자료구조를 구현할 수 있다.
- 예시) 스택, 큐 등
- js 는 연결 리스트를 활용하는 자료구조를 제공

## 연결 리스트 vs 배열

- 연결 리스트와 배열을 비교하여 장단점을 이해할 필요가 있다.
- 특정 위치의 데이터를 삭제할 때, 일반적인 배열에서는 O(N) 만큼의 시간이 소요된다.
- 하지만, 연결 리스트를 이용하면 단순히 연결만 끊어주면 된다.
- 따라서 삭제할 위치를 정확히 알고 있는 경우 O(1)의 시간이 소요 된다.

# 스택 (Stack)

- 스택: 먼저 들어온 데이터가 나중에 나가는 자료구조
- 흔히 박스가 쌓인 형태를 스택 이라고 한다.
- 새로운 원소를 삽입할 때는 마지막 위치에 삽입한다.
- 새로운 원소를 삭제할 때는 마지막 원속가 삭제된다.

## 스택 자료구조의 시간 복잡도

|     | 연산              | 시간 복잡도 | 설명                                                     |
| --- | ----------------- | ----------- | -------------------------------------------------------- |
| 1   | 삽입(push)        | O(1)        | 스택에 원소를 삽입하는 연산                              |
| 2   | 추출(pop)         | O(1)        | 스택에서 원소를 추출하는 연산                            |
| 3   | 최상위 원소 (Top) | O(1)        | 스택의 최상위 원소(마지막에 들어온 원소)를 확인하는 연산 |
| 4   | Empty             | O(1)        | 스택이 비어 있는지 확인하는 연산                         |

## js 에서 스택을 구현하는 방법 - 배열 자료형

- js의 기본적인 배열 자료형은 다음의 두 가지 메서드를 젝공한다.
- push(): 마지막 위치에 원손를 삽입하며, 시간 복잡도는 O(1) 이다.
- pop(): 마지막 위치에서 원소를 추출하며, 시간 복잡도는 O(1) 이다.

## 연결 리스트로 스택 구현 하기

- 스택을 연결 리스트로 구현하면, 삽입과 삭제에 있어서 O(1) 을 보장할 수 있다.
- 연결 리스트로 구현할 때는 머리를 가리키는 하나의 개의 포인터만 가진다.
- 머리(Head): 남아있는 원소 중 가장 마지막에 들어 온 데이터를 가리키는 포인터

- 삽입할 때는 머리 위치에 데이터를 넣는다.
- 삭제할 때는 머리 위치에서 데이터를 꺼낸다.

# 큐 (Queue)

- 큐는 먼저 삽입된 데이터가 먼저 추출되는 자료구조
- 예) 놀이동산에서 줄을 서는것과 같음

## 연결리스트로 큐 구현

- 큐를 연결 리스트로 구현하면, 삽입과 삭제에 있어서 O(1)을 보장할 수 있다.
- 연결 리스트로 구현할 때는 머리 와 꼬리 두 개의 포인터를 가진다.
- 머리: 남아있는 원소 중 가장 먼저 들어 온 데이터를 가리키는 포인터
- 꼬리: 남아있는 원소 중 가장 마지막에 들어온 데이터를 가리키는 포인터

## 큐 동작 속도: 배열 vs 연결 리스트

- 다수의 데이터를 삽입 및 삭제할 때에 대하여, 수행 시간을 측정할 수 있다.
- 단순히 배열 자료형을 이용할 때보다 연결 리스트를 사용할 때 수행 시간 관점에서 효율적이다.
- js 에서는 Dictionary 자료형을 이용하여 큐를 구현하면 간단 하다.

## JS 큐 구현하기

```
class Queue {
  constructor() {
    this.items = {};
    this.headIndex = 0;
    this.tailIndex = 0;
  }
  enqueue(item) {
    this.items[this.tailIndex] = item;
    this.tailIndex++;
  }
  dequeue() {
    const item = this.items[this.headIndex];
    delete this.items[this.headIndex];
    this.headIndex++;
    return item;
  }
  peek() {
    return this.items[this.headIndex];
  }
  getLength() {
    return this.tailIndex - this.headIndex;
  }
}

// 구형된 큐 라이브러리 사용
queue = new Queue();

// 5 삽입 - 2 삽입 - 3 삽입 - 7 삽입 - 삭제 - 1 삽입 - 4 삽입 - 삭제
queue.enqueue(5);
queue.enqueue(2);
queue.enqueue(3);
queue.enqueue(7);
queue.dequeue();
queue.enqueue(1);
queue.enqueue(4);
queue.dequeue();

// 먼저 들어온 순서대로 출력
while(queue.getlength() != 0) {
  console.log(queue.dequeue());
}

// 출력
// 3
// 7
// 1
// 4
```
